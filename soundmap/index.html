<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sound Map — miomiomi.org</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin></script>

  <!-- クリップ＆バッファ用 -->
  <script src="https://cdn.jsdelivr.net/npm/leaflet-boundary-canvas@1.0.0/src/BoundaryCanvas.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6.5.0/turf.min.js"></script>

  <!-- サイトのトーン（背景/文字色・フォント） -->
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#F1F1F1; --text:#5A5A5A; --border:#ddd; --accent:#007aff; }
    html,body{height:100%;}
    body{margin:0;background:var(--bg);color:var(--text);font-size:14px;}
    a{color:var(--text);text-decoration:none;border-bottom:1px dotted #aaa;}
    header{font-size:16px;margin:16px 10px;}
    header a{border:0;}

    .wrap{display:grid;grid-template-columns:1.3fr 1fr;gap:12px;padding:0 2% 2%;}
    #map{width:100%;height:70vh;border:1px solid var(--border);background:#fafafa;position:relative;}

    .panel{border:1px solid var(--border);background:#fff;padding:12px;display:flex;flex-direction:column;gap:10px;border-radius:8px;}
    .panel h2{font-size:14px;margin:0 0 6px;font-weight:bold;color:var(--text);}

    @media (max-width:900px){
      .wrap{grid-template-columns:1fr;}
      #map{height:55vh;}
    }

    .leaflet-marker-icon{filter:grayscale(100%);}
    .leaflet-attribution-flag {display: none !important;}

    /* 位置記録コントロール（地図右上） */
    .track-controls{
      position:absolute; right:10px; top:10px; z-index:1000;
      background:#fff; border:1px solid var(--border); border-radius:10px;
      padding:10px; box-shadow:0 2px 6px rgba(0,0,0,.06); font-size:12px; min-width:300px;
    }
    .track-controls h3{margin:0 0 6px; font-size:12px;}
    .row{display:flex; gap:6px; align-items:center; flex-wrap:wrap; margin:4px 0;}
    .row button{
      padding:6px 10px; border:1px solid var(--border); background:#fff; border-radius:6px; cursor:pointer;
    }
    .row button.primary{border-color:var(--accent); color:#fff; background:var(--accent);}
    .row button:disabled{opacity:.5; cursor:not-allowed;}
    .row .time{min-width:120px; font-variant-numeric:tabular-nums;}
    .row .grow{flex:1;}
    .row input[type="range"]{width:100%;}

    /* 現在地ボタン（右下） */
    .locate-box{
      position:absolute; right:10px; bottom:10px; z-index:1000;
      background:#fff; border:1px solid var(--border); border-radius:10px;
      padding:8px; box-shadow:0 2px 6px rgba(0,0,0,.06); font-size:12px;
      display:flex; gap:8px; align-items:center;
    }
    .locate-box button{
      padding:6px 10px; border:1px solid var(--border); background:#fff; border-radius:6px; cursor:pointer;
    }
    .locate-box button.active{ border-color:var(--accent); color:#fff; background:var(--accent); }
    .legend-dot{width:10px;height:10px;border-radius:50%;background:#007aff;border:2px solid #fff;box-shadow:0 0 0 2px #007aff;}

    /* ログインパネル（未認証時に表示） */
    #loginPanel{
    position:absolute; right:10px; left:auto; top:10px; z-index:1001;
    background:transparent; border:0; padding:0; box-shadow:none;
    }
    #loginPanel button{
    font-size:12px;            /* 小さめ */
    padding:4px 8px;           /* 小さめ */
    border:1px solid var(--border);
    background:#fff; border-radius:6px; cursor:pointer;
    }
    /* --- My Tracks パネル --- */
    #myTracksPanel .tools { display:flex; gap:8px; align-items:center; }
    #myTracksList { display:flex; flex-direction:column; gap:8px; margin-top:8px; }
    .track-item { border:1px solid var(--border); border-radius:8px; padding:8px; display:grid; grid-template-columns:1fr auto; gap:6px; }
    .track-title { font-weight:600; }
    .badge { font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid var(--border); }
    .badge.pub { background:#e8f4ff; border-color:#cde6ff; }
    .badge.prv { background:#f6f6f6; }
    .actions { display:flex; gap:6px; }
    .actions button { padding:4px 8px; border:1px solid var(--border); background:#fff; border-radius:6px; cursor:pointer; font-size:12px; }
    /* --- Tracks 行内のプレイヤー --- */
    .track-item .player{ margin-top:8px; padding-top:6px; border-top:1px solid var(--border); }
    .track-item .controls{ display:flex; align-items:center; gap:8px; margin-bottom:6px; }
    .track-item .controls button{ padding:4px 8px; border:1px solid var(--border); background:#fff; border-radius:6px; font-size:12px; cursor:pointer; }
    .track-item .time{ font-size:12px; opacity:.8; min-width:120px; }
    .track-item input[type="range"]{ width:100%; }
    /* 記録モード選択モーダル */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.4);
      display:flex; align-items:center; justify-content:center; z-index:2000; }
    .modal.hidden{ display:none; }
    .modal-card{ background:#fff; border:1px solid var(--border); border-radius:12px;
      padding:16px; box-shadow:0 6px 24px rgba(0,0,0,.12); width:min(420px,90vw); }
    /* パネルのシークバーはUIから消す（内部では存続） */
    #progress { display: none !important; }
    /* 旧ボタンはUIから隠す（内部ではclick代行で使用） */
    #btnStart,#btnStop,#btnPlay,#btnPause,#btnSave{ display:none !important; }

    /* 統一ボタンの見た目（ライト） */
    .u-btn{
      position:relative; display:grid; place-items:center;
      width:64px; height:64px; border-radius:999px; cursor:pointer;
      background:#fff; color:#111827; border:1px solid var(--border);
      box-shadow:0 8px 18px rgba(0,0,0,.06), inset 0 0 0 2px rgba(0,0,0,.02);
      transition:transform .08s ease, background .2s ease, box-shadow .2s ease, border-color .2s ease, opacity .2s ease;
    }
    .u-btn:hover{ box-shadow:0 12px 24px rgba(0,0,0,.08); }
    .u-btn:active{ transform:translateY(1px); }
    .u-btn:disabled{ opacity:.45; filter:grayscale(.2); cursor:not-allowed; }
    .u-btn .ic{ width:28px; height:28px; display:none }

    /* RECの各状態 */
    #recBtn.idle .ic-record{ display:block; }
    #recBtn .ic-record circle{ fill:#ff3b30; }

    #recBtn.recording{ border-color:#fca5a5; }
    #recBtn.recording .ic-stop{ display:block; }
    #recBtn .ic-stop rect{ fill:#ff3b30; }
    #recBtn.recording::before{
      content:""; position:absolute; inset:-8px; border-radius:999px; pointer-events:none;
      background:radial-gradient(closest-side, rgba(255,59,48,.18), rgba(255,59,48,0));
      filter:blur(8px); animation:recGlow 2.2s ease-in-out infinite;
    }
    @keyframes recGlow{ 0%{opacity:.3; transform:scale(.95);} 50%{opacity:.7; transform:scale(1.05);} 100%{opacity:.3; transform:scale(.95);} }

    #recBtn.ready{ border-color:#d1d5db; }
    #recBtn.ready .ic-check-outline{ display:block; }
    #recBtn .ic-check-outline path{
      stroke:#9ca3af; stroke-width:4.5; stroke-linecap:round; stroke-linejoin:round; fill:none;
    }

    #recBtn.saving{ background:#f0fdf4; border-color:#bbf7d0; }
    #recBtn .spinner{
      width:18px; height:18px; border:3px solid rgba(0,0,0,.18); border-top-color:#111827;
      border-radius:999px; animation:spin .9s linear infinite; display:none;
    }
    #recBtn.saving .spinner{ display:block; }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    #recBtn.saved{ background:#17c964; border-color:transparent; color:#fff; }
    #recBtn.saved .ic-check-solid{ display:block; }
    #recBtn .ic-check-solid path{
      stroke:#fff; stroke-width:5; stroke-linecap:round; stroke-linejoin:round; fill:none;
    }

    /* Play/Pauseの見た目 */
    #playBtn .ic-play{ display:block; }
    #playBtn .ic-play path{ fill:#111827; }
    #playBtn.playing{ background:#111827; color:#fff; }
    #playBtn.playing .ic-play{ display:none; }
    #playBtn.playing .ic-pause{ display:block; }
    #playBtn.playing .ic-pause rect{ fill:#fff; }

  </style>
</head>
<body>
  <header><a href="/">yes, I'm dreaming.</a></header>

  <div class="wrap">
    <div id="map" aria-label="録音と画像のサウンドマップ">
      <!-- 未認証時にだけ出すボックス -->
      <section id="loginPanel">
        <button id="btnAdminLogin" aria-label="Admin login">Admin login</button>
      </section>
      

      <!-- 管理者用の記録パネル（最初は隠す） -->
      <section id="recPanel" hidden>
        <!-- 位置記録・再生コントロール -->
        <div class="track-controls" id="trackCtrl">
          <h3>移動ログ</h3>
          <!-- 統合コントローラ：REC & Play -->
          <div class="row" id="unifiedCtrl" style="gap:12px; align-items:center">
            <!-- REC三変化 -->
            <button id="recBtn" class="u-btn idle" aria-label="Start recording" title="Start recording">
              <!-- idle: 赤● -->
              <svg class="ic ic-record" viewBox="0 0 48 48" aria-hidden="true"><circle cx="24" cy="24" r="14"/></svg>
              <!-- recording: 赤■ -->
              <svg class="ic ic-stop" viewBox="0 0 48 48" aria-hidden="true"><rect x="14" y="14" width="20" height="20" rx="6"/></svg>
              <!-- ready: 薄グレーのフチ✓ -->
              <svg class="ic ic-check-outline" viewBox="0 0 48 48" aria-hidden="true"><path d="M12 25 l8 8 L36 16"/></svg>
              <!-- saved flash: 緑✓ -->
              <svg class="ic ic-check-solid" viewBox="0 0 48 48" aria-hidden="true"><path d="M12 25 l8 8 L36 16"/></svg>
              <div class="spinner" aria-hidden="true"></div>
            </button>

            <!-- Play / Pause（停止直後＝readyで有効化、再生中はPause表示） -->
            <button id="playBtn" class="u-btn" aria-label="Play" title="Play" disabled>
              <!-- play -->
              <svg class="ic ic-play" viewBox="0 0 48 48" aria-hidden="true"><path d="M18 14 L36 24 L18 34 Z"/></svg>
              <!-- pause -->
              <svg class="ic ic-pause" viewBox="0 0 48 48" aria-hidden="true">
                <rect x="14" y="12" width="8" height="24" rx="2"/><rect x="26" y="12" width="8" height="24" rx="2"/>
              </svg>
            </button>

            <!-- 既存の時間表示は流用 -->
            <span class="time" id="recLen">--:--</span>
            <span class="time" id="playLen">--:-- / --:--</span>
          </div>

          <div class="row">
            <button id="btnStart" class="primary" aria-label="Start recording">Start</button>
            <button id="btnStop" disabled aria-label="Stop recording">Stop</button>
            <span class="time" id="recLen">--:--</span>
          </div>
          <div class="row">
            <button id="btnPlay" disabled aria-label="Play">Play</button>
            <button id="btnPause" disabled aria-label="Pause">Pause</button>
            <span class="time" id="playLen">--:-- / --:--</span>
          </div>
          <div class="row">
            <input id="progress" class="grow" type="range" min="0" max="1000" value="0" step="1" />
          </div>
          <div class="row" style="justify-content:flex-end;gap:8px">
            <button id="btnSave" disabled aria-label="Save">Save</button>
          </div>
          <hr style="margin:8px 0;border:none;border-top:1px solid var(--border);" />
          
          <!-- 記録モード選択モーダル -->
          <div id="startChoice" class="modal hidden" role="dialog" aria-modal="true">
            <div class="modal-card">
              <h3 style="margin:0 0 8px;">記録モード</h3>
              <p style="margin:0 0 12px;">開始方法を選んでください。</p>
              <div class="row" style="justify-content:flex-end; gap:8px;">
                <button id="chooseCancel" class="danger" aria-label="キャンセル">キャンセル</button>
                <button id="chooseGeo" aria-label="移動のみ記録する">移動のみ</button>
                <button id="chooseBoth" class="primary" aria-label="音と移動を記録する">音声と移動</button>
              </div>
            </div>
          </div>

          <div class="row">
            <audio id="recAudio" controls hidden></audio>
          </div>

        </div>

        <!-- 現在地コントロール -->
        <div class="locate-box" id="locateBox">
          <span class="legend-dot" aria-hidden="true"></span>
          <button id="btnLocate" title="現在地の表示/非表示を切替">現在地</button>
          <label style="display:flex;align-items:center;gap:4px;user-select:none;">
            <input type="checkbox" id="chkFollow" checked /> フォロー
          </label>
        </div>
      </section>
    </div>
    <!--認証の有無に関わらず表示 -->
    <aside class="panel" id="myTracksPanel" hidden>
      <h2 id="myTracksTitle">Tracks</h2>
      <div class="tools">
        <button id="btnRefreshTracks">Refresh</button>
      </div>
      <div id="myTracksList" aria-live="polite"></div>
    </aside>
  </div>
  <script>
    // ---------------- 地図 ----------------
    const map = L.map('map', { zoomControl: true, attributionControl: true });

    // ベース：OSM（常時表示）
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '<a href="https://www.openstreetmap.org/copyright">© OpenStreetMap contributors</a>',
      maxZoom: 19
    }).addTo(map);

    // 再生表示用オーバーレイ（任意のトラックを再生するときに使う）
    const viewGroup = L.layerGroup().addTo(map);
    let viewFull = null, viewProg = null, viewHead = null;
    let activeRowId = null;

    // 実測スピード再生で使う状態
    let viewPlaying = false, viewRAF = 0;
    let viewStartWall = 0, viewStartT = 0;    // 壁時計と、再生開始時のトラック内時刻(ms)
    let viewDurMs = 0;                        // トラック全体の長さ(ms)
    let viewLatLngs = [];                     // [[lat,lng], ...]
    let viewTimes = [];                       // 各点の時刻(ms, 先頭を0に正規化）
    let viewHasTimes = false;                 // times が本当にあったか
    let viewCum = [];                         // 距離の累積（見栄え用）
    let viewTotal = 0;

    function cleanupViewLayers(){
      viewPlaying = false;
      if (viewRAF) cancelAnimationFrame(viewRAF); viewRAF = 0;
      viewGroup.clearLayers();
      viewFull = viewProg = viewHead = null;
      viewLatLngs = [];
      viewTimes = [];
      viewCum = [];
      viewTotal = 0;
      viewDurMs = 0;
      viewHasTimes = false;
    }


    // 公開トラック描画用のグループ（再読み込みで消して描き直す）
    let publicGroup = L.layerGroup().addTo(map);

    let gsi = null;

// 日本外周ポリゴン（凸包） → 少し外側にオフセットして GSI を“内側だけ”描画
fetch('japan_outer_hull.geojson')
  .then(r => r.json())
  .then(boundary => {
    const BUFFER_KM = 23;
    const buffered = turf.buffer(boundary, BUFFER_KM, { units: 'kilometers' });

    const tmp = L.geoJSON(buffered);
    map.fitBounds(tmp.getBounds());

    gsi = new L.TileLayer.BoundaryCanvas(
      'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png',
      {
        boundary: buffered,
        maxZoom: 18,
        attribution: '<a href="https://maps.gsi.go.jp/development/ichiran.html">地理院タイル</a>'
      }
    ).addTo(map);
  });
    // ---------------- 位置記録 & 再生 ----------------
    const btnStart = document.getElementById('btnStart');
    const btnStop  = document.getElementById('btnStop');
    const btnPlay  = document.getElementById('btnPlay');
    const btnPause = document.getElementById('btnPause');
    const btnSave  = document.getElementById('btnSave');
    const recLenEl = document.getElementById('recLen');
    const playLenEl= document.getElementById('playLen');
    const progress = document.getElementById('progress');

    // --- 統合ボタンの状態管理 ---
    const recBtn  = document.getElementById('recBtn');
    const playBtn = document.getElementById('playBtn');
    let recState = 'idle';     // 'idle' | 'recording' | 'ready' | 'saving' | 'saved'
    function setRecState(s){
      recState = s;
      recBtn.classList.remove('idle','recording','ready','saving','saved');
      recBtn.classList.add(s);
      recBtn.setAttribute('aria-label',
        s==='idle'?'Start recording' :
        s==='recording'?'Stop recording' :
        s==='ready'?'Save recording' :
        s==='saving'?'Saving...' : 'Saved');
      recBtn.title = recBtn.getAttribute('aria-label');

      // 停止直後＝ready でプレビュー再生を解放
      if (s === 'ready')  { playBtn.disabled = false; }
      if (s === 'idle' || s === 'recording' || s === 'saving') { playBtn.disabled = true; setPlaying(false); }
      if (s === 'saved')  { setTimeout(()=> setRecState('idle'), 900); } // 緑フラッシュ後に戻す
    }

    let isPlayingUI = false;
    function setPlaying(p){
      isPlayingUI = p;
      if (p) {
        playBtn.classList.add('playing');
        playBtn.setAttribute('aria-label','Pause'); playBtn.title = 'Pause';
      } else {
        playBtn.classList.remove('playing');
        playBtn.setAttribute('aria-label','Play'); playBtn.title = 'Play';
      }
    }

    // クリック（見た目→既存ボタンに代行クリック）
    recBtn?.addEventListener('click', ()=>{
      if (recState === 'idle')      { btnStart.click(); setRecState('recording'); }
      else if (recState === 'recording'){ btnStop.click();  setRecState('ready');     }
      else if (recState === 'ready'){   // 保存
        setRecState('saving');
        // 保存完了で saved→idle へ（afterSavedをラップ）
        const _after = window.afterSaved;
        window.afterSaved = async function(id){
          try { await _after(id); } finally { setRecState('saved'); }
        };
        btnSave.click();
      }
    });

    playBtn?.addEventListener('click', ()=>{
      if (playBtn.disabled) return;
      if (!isPlayingUI) { btnPlay.click(); setPlaying(true); }
      else { btnPause.click(); setPlaying(false); }
    });

    // 既存ボタンの結果でUIを同期（保険）
    btnStart?.addEventListener('click', ()=> setRecState('recording'));
    btnStop ?.addEventListener('click', ()=> setRecState('ready'));
    btnPlay ?.addEventListener('click', ()=> setPlaying(true));
    btnPause?.addEventListener('click', ()=> setPlaying(false));
    // 保存完了時にもUIをidleへ戻す（二重呼び出しでも問題なし）
    if (typeof window.afterSaved === 'function') {
      const _old = window.afterSaved;
      window.afterSaved = async function(id){ try{ await _old(id); } finally{ setRecState('saved'); } };
    }


    // 記録データ：[{lat,lng,t(ms)}...]
    let watchId = null;
    let track = [];
    let t0 = 0;            // 記録開始の絶対時刻（ms）
    let durationMs = 0;    // 記録総時間
    let fullLine = null;   // 全体パス（灰）
    let progLine = null;   // 進捗パス（青）
    let headMarker = null; // 再生ヘッド（現在位置）
    let recTimerId = 0;    // 経過表示タイマー
    let keepAliveId = 0;   // 静止中キープアライブ

    // ---- 音声録音用 ----
    let micStream = null;
    let mediaRec = null;
    let audioChunks = [];
    let audioBlob = null;
    let audioUrl = "";
    let micTimerId = 0;
    let micT0 = 0;

    // ブラウザ毎に妥当な mimeType を探す
    function pickAudioMime(){
      const candidates = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/mp4',                 // Safari系
        'audio/ogg;codecs=opus',
        'audio/ogg',
        'audio/wav'
      ];
      for (const type of candidates){
        if (MediaRecorder.isTypeSupported?.(type)) return type;
      }
      return ''; // からの場合はブラウザに委ねる
    }

    function fmtMic(sec){
      sec = Math.max(0, Math.floor(sec));
      const m = Math.floor(sec/60).toString().padStart(2,'0');
      const s = (sec%60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }
    async function startMic(){
      if (!navigator.mediaDevices?.getUserMedia){
        alert('このブラウザはマイク録音に対応していません'); return;
      }
      // 既に動いていればいったんクリア
      await stopMic(false);

      // マイク権限＆ストリーム取得
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mimeType = pickAudioMime();
      audioChunks = [];
      audioBlob = null;
      audioUrl && URL.revokeObjectURL(audioUrl); audioUrl = "";

      mediaRec = new MediaRecorder(micStream, mimeType ? { mimeType } : undefined);
      mediaRec.ondataavailable = e => { if (e.data && e.data.size) audioChunks.push(e.data); };
      mediaRec.onstop = () => {
        if (!audioChunks.length) return;
        const type = mediaRec.mimeType || 'audio/webm';
        audioBlob = new Blob(audioChunks, { type });
        audioUrl = URL.createObjectURL(audioBlob);
        const audioEl = document.getElementById('recAudio');
        if (audioEl){
          audioEl.src = audioUrl;
          audioEl.hidden = true;      // ← UIは出さず、進行バーで制御
          audioEl.controls = false;
        }
      };

      mediaRec.start(1000); // 1秒刻みで chunk を受け取る
      micT0 = Date.now();
      const micStatus = document.getElementById('micStatus');
      if (micTimerId) clearInterval(micTimerId);
      micTimerId = setInterval(()=>{
        const sec = (Date.now() - micT0)/1000;
        if (micStatus) micStatus.textContent = fmtMic(sec);
      }, 250);

      // UI
      document.getElementById('btnMicStart')?.setAttribute('disabled','');
      document.getElementById('btnMicStop')?.removeAttribute('disabled');
    }

    async function stopMic(showLength = true){
      try{
        if (mediaRec && mediaRec.state !== 'inactive'){
          await new Promise(res=>{
            mediaRec.addEventListener('stop', res, { once:true });
            mediaRec.stop();
          });
        }
      }catch(e){ console.warn(e); }
      try{
        micStream?.getTracks?.().forEach(tr=>tr.stop());
      }catch(e){ /* ignore */ }
      micStream = null; mediaRec = null;

      if (micTimerId){ clearInterval(micTimerId); micTimerId = 0; }
      const micStatus = document.getElementById('micStatus');
      if (micStatus){
        micStatus.textContent = showLength && micT0 ? fmtMic((Date.now()-micT0)/1000) : '--:--';
      }
      document.getElementById('btnMicStart')?.removeAttribute('disabled');
      document.getElementById('btnMicStop')?.setAttribute('disabled','');
    }
    // ---- 記録モード選択ダイアログ ----
    // 戻り値: 'both' | 'geo' | null（キャンセル）
    function chooseStartMode(){
      return new Promise((resolve)=>{
        const modal = document.getElementById('startChoice');
        const bBoth = document.getElementById('chooseBoth');
        const bGeo  = document.getElementById('chooseGeo');
        const bCancel = document.getElementById('chooseCancel');

        function close(v){
          modal.classList.add('hidden');
          bBoth.removeEventListener('click', onBoth);
          bGeo.removeEventListener('click', onGeo);
          bCancel.removeEventListener('click', onCancel);
          resolve(v);
        }
        function onBoth(){ close('both'); }
        function onGeo(){  close('geo'); }
        function onCancel(){ close(null); }

        // 開く & ハンドラ登録
        modal.classList.remove('hidden');
        bBoth.addEventListener('click', onBoth);
        bGeo .addEventListener('click', onGeo);
        bCancel.addEventListener('click', onCancel);
      });
    }


    // 再生管理
    let playing = false;
    let playStartWall = 0; // 再生開始の壁時計（ms）
    let playStartT = 0;    // 再生開始時のトラック内時刻（ms）
    let rafId = 0;

    // ---- 記録開始
    btnStart.addEventListener('click', async ()=>{
      // 既存データ/描画が残っているなら確認
      const hasExisting =
        (track && track.length > 0) || fullLine || progLine || headMarker;
      if (hasExisting) {
        const ok = confirm("リセットしてやり直しますか？Start a new recording? The current path will be cleared.");
        if (!ok) return; // キャンセルで中断

        // 念のため測位やタイマーを停止
        if (watchId != null) { navigator.geolocation.clearWatch(watchId); watchId = null; }
        stopRecTimer();
        stopKeepAlive();
        playing = false; if (rafId) cancelAnimationFrame(rafId);

        // 既存表示と状態をクリア
        cleanupTrackLayers();
        track = [];
        durationMs = 0;
        progress.value = 0;
        progress.max = 1000;
        recLenEl.textContent = '--:--';
        playLenEl.textContent = '--:-- / --:--';
      }

      if (!navigator.geolocation) {
        alert('このブラウザは位置情報に対応していません');
        return;
      }

      // 新規記録の初期化
      track = [];
      lastPushT = 0;      // 既存の変数（なければ上部で let lastPushT = 0; を宣言）
      lastLatLng = null;  // 既存の変数（なければ上部で let lastLatLng = null; を宣言）
      t0 = Date.now();
      recLenEl.textContent = '00:00';
      durationMs = 0;
      startRecTimer();
      startKeepAlive();

      // 最初の1点をすぐ取得
      navigator.geolocation.getCurrentPosition(pos=>{
        pushSample(pos);
      }, err=>console.warn(err), {enableHighAccuracy:true, maximumAge:0, timeout:10000});

      // ★ 記録モード選択（音+移動 or 移動のみ）
      const mode = await chooseStartMode();
      if (mode === null) return;               // キャンセル
      let withAudio = (mode === 'both');
      // 事前クォータ確認（残りが少なければ音声OFFで開始）
      if (withAudio) {
        try {
          const u = await fetch('/api/private/tracks/usage').then(r=>r.json());
          // 最低バッファ 512KB（任意に調整）
          if ((u?.remaining_bytes ?? Infinity) <= 512 * 1024) {
            alert('サーバ容量の上限に近いため移動のみで記録を開始します。Server near capacity - logging moves only.');
            withAudio = false;
          }
        } catch(e) { console.warn('quota precheck failed', e); }
      }
      
      // 継続測位
      watchId = navigator.geolocation.watchPosition(pos=>{
        pushSample(pos);
      }, err=>console.warn(err), {enableHighAccuracy:true, maximumAge:0});

      // ボタン状態
      btnStart.disabled = true;
      btnStop.disabled = false;
      btnPlay.disabled = true;
      btnPause.disabled = true;
      btnSave.disabled = true;
      progress.value = 0;
      playLenEl.textContent = '--:-- / --:--';

      // ★ ユーザーが「音も記録する」を選んだ場合だけマイク開始
      if (withAudio) {
        try {
          await startMic();
        } catch(e) {
          console.warn('mic start failed', e);
          // マイクNGでも位置記録は継続する
        }
      }

      // Micボタンは記録中だけ触れるように
      document.getElementById('btnMicStart')?.setAttribute('disabled','');
      document.getElementById('btnMicStop') ?.removeAttribute('disabled');
    });
    // ---- 記録終了
    btnStop.addEventListener('click', ()=>{
      if (watchId != null) navigator.geolocation.clearWatch(watchId);
      watchId = null;
      stopRecTimer();
      stopKeepAlive();
      btnStart.disabled = false;
      btnStop.disabled = true;

      if (track.length === 0) {
        alert('位置データが取得できませんでした。No location points were captured.');
        return;
      }
      if (track.length === 1) {
        const now = Date.now();
        const p0 = track[0];
        track.push({ lat: p0.lat, lng: p0.lng, t: now });
      }

      durationMs = track[track.length-1].t - track[0].t;
      progress.max = Math.max(1, durationMs); // ms
      progress.value = 0;
      recLenEl.textContent = fmt(durationMs/1000);
      playLenEl.textContent = `00:00 / ${fmt(durationMs/1000)}`;

      const latlngs = track.map(p=>[p.lat, p.lng]);
      fullLine = L.polyline(latlngs, {color:'#666', weight:4, opacity:0.5}).addTo(map);
      progLine = L.polyline([], {color: '#007aff', weight:5, opacity:1}).addTo(map);
      headMarker = L.circleMarker(latlngs[0], {radius:6, color:'#007aff', fillColor:'#fff', fillOpacity:1, weight:3}).addTo(map);

      const b = L.latLngBounds(latlngs);
      map.fitBounds(b.pad(0.2));
      //地図上シークを有効化
      enableTrackMapSeek();

      // マイクも止める
      stopMic();

      // Micボタンは通常状態へ
      document.getElementById('btnMicStart')?.removeAttribute('disabled');
      document.getElementById('btnMicStop') ?.setAttribute('disabled','');

      btnPlay.disabled = false;
      btnPause.disabled = true;
      btnSave.disabled = false; // ★ 保存できる
    });

    // ---- 再生
    btnPlay.addEventListener('click', ()=>{
      if (track.length < 2) return;
      if (!playing) {
        playing = true;
        btnPlay.disabled = true;
        btnPause.disabled = false;
        playStartWall = performance.now();
        playStartT = Number(progress.value);
        // ★ 音声も同じ位置から再生
        const audioEl = document.getElementById('recAudio');
        if (audioEl && audioEl.src) {
          if (audioEl.readyState >= 1) { audioEl.currentTime = playStartT/1000; }
          else { audioEl.addEventListener('loadedmetadata', ()=>{ audioEl.currentTime = playStartT/1000; }, { once:true }); }
          audioEl.play().catch(e=>console.warn('audio play failed', e));
        }
        tick();
      }
    });

    // ---- 一時停止
    btnPause.addEventListener('click', ()=>{
      if (!playing) return;
      playing = false;
      btnPlay.disabled = false;
      btnPause.disabled = true;
      if (rafId) cancelAnimationFrame(rafId);
      const audioEl = document.getElementById('recAudio');
      if (audioEl) { try{ audioEl.pause(); }catch{} }
    });

    // ---- シーク（つまみ操作で移動）
    progress.addEventListener('input', ()=>{
      if (track.length < 2) return;
      const t = Number(progress.value);
      renderAt(t);
      playLenEl.textContent = `${fmt(t/1000)} / ${fmt(durationMs/1000)}`;
      const audioEl = document.getElementById('recAudio');
      if (audioEl && audioEl.src) {
        if (audioEl.readyState >= 1) audioEl.currentTime = t/1000;
        else audioEl.addEventListener('loadedmetadata', ()=> audioEl.currentTime = t/1000, { once:true });
      }
    });

    // ---- 毎フレーム進める
    function tick(){
      if (!playing) return;
      const elapsed = performance.now() - playStartWall; // ms
      let t = playStartT + elapsed;
      if (t >= durationMs) {
        t = durationMs;
        renderAt(t);
        progress.value = t;
        playLenEl.textContent = `${fmt(t/1000)} / ${fmt(durationMs/1000)}`;
        playing = false;
        btnPlay.disabled = false;
        btnPause.disabled = true;
        const audioEl = document.getElementById('recAudio');
        if (audioEl && !audioEl.paused) { try{ audioEl.pause(); }catch{} }
        return;
      }
      renderAt(t);
      progress.value = t;
      playLenEl.textContent = `${fmt(t/1000)} / ${fmt(durationMs/1000)}`;
      rafId = requestAnimationFrame(tick);
    }

    // ---- t(ms) 時点の位置まで“進捗パス”を描画
    function renderAt(t){
      if (!progLine || track.length<2) return;
      const pts = [];
      for (let i=0;i<track.length-1;i++){
        const a = track[i], b = track[i+1];
        if (i===0) pts.push([a.lat,a.lng]);
        if (t >= b.t - track[0].t) {
          pts.push([b.lat,b.lng]);
          continue;
        }
        if (t <= a.t - track[0].t) { break; }
        const ta = a.t - track[0].t, tb = b.t - track[0].t;
        const ratio = (t - ta) / (tb - ta);
        const lat = a.lat + (b.lat - a.lat)*ratio;
        const lng = a.lng + (b.lng - a.lng)*ratio;
        pts.push([lat,lng]);
        break;
      }
      progLine.setLatLngs(pts);
      if (headMarker && pts.length){
        headMarker.setLatLng(pts[pts.length-1]);
      }
    }
  // ===== Map seek (クリック/ドラッグ/タッチで地図上シーク) =====
  const _seek = { latlngs: [], px: [], cum: [], total: 0 };

  function buildSeekCache(){
    if (!fullLine || !track?.length) return;
    _seek.latlngs = track.map(p => L.latLng(p.lat, p.lng));
    _seek.px = _seek.latlngs.map(ll => map.latLngToLayerPoint(ll));
    _seek.cum = [0];
    let acc = 0;
    for (let i=0;i<_seek.latlngs.length-1;i++){
      acc += _seek.latlngs[i].distanceTo(_seek.latlngs[i+1]); // meters
      _seek.cum.push(acc);
    }
    _seek.total = acc || 1;
  }

  function timeFromLatLng(ll){
    if (!_seek.px.length || !durationMs) return null;
    const p = map.latLngToLayerPoint(ll);
    let bestI=0, bestT=0, bestD2=Infinity;
    for (let i=0;i<_seek.px.length-1;i++){
      const a=_seek.px[i], b=_seek.px[i+1];
      const vx=b.x-a.x, vy=b.y-a.y;
      const wx=p.x-a.x, wy=p.y-a.y;
      const vv = vx*vx+vy*vy || 1;
      let t = (vx*wx+vy*wy)/vv; t=Math.max(0,Math.min(1,t));
      const projX=a.x+vx*t, projY=a.y+vy*t;
      const dx=p.x-projX, dy=p.y-projY;
      const d2=dx*dx+dy*dy;
      if (d2 < bestD2){ bestD2=d2; bestI=i; bestT=t; }
    }
    const seg = _seek.latlngs[bestI].distanceTo(_seek.latlngs[bestI+1]);
    const dist = _seek.cum[bestI] + seg*bestT;
    const frac = dist / _seek.total;
    return Math.round(frac * durationMs);
  }

  function enableTrackMapSeek(){
    if (!fullLine) return;
    buildSeekCache();
    map.on('zoomend', buildSeekCache);

    // クリックでジャンプ（PC）
    fullLine.on('click', (e)=>{
      const ms = timeFromLatLng(e.latlng);
      if (ms==null) return;
      playing = true;
      btnPlay.disabled = true; btnPause.disabled = false;
      playStartWall = performance.now(); playStartT = ms;

      const a = document.getElementById('recAudio');
      if (a && a.src){
        if (a.readyState >= 1) a.currentTime = ms/1000;
        else a.addEventListener('loadedmetadata', ()=> a.currentTime = ms/1000, {once:true});
        a.play().catch(()=>{});
      }
      tick();
    });

    // ドラッグでプレビュー（PC）
    const onMove = (ev)=>{
      const ms = timeFromLatLng(ev.latlng);
      if (ms==null) return;
      if (rafId) cancelAnimationFrame(rafId);
      playing = false; btnPlay.disabled=false; btnPause.disabled=true;
      renderAt(ms);
      progress.value = ms;
      playLenEl.textContent = `${fmt(ms/1000)} / ${fmt(durationMs/1000)}`;
      const a = document.getElementById('recAudio');
      if (a && a.src){
        if (a.readyState >= 1) a.currentTime = ms/1000;
        else a.addEventListener('loadedmetadata', ()=> a.currentTime = ms/1000, {once:true});
        a.pause?.();
      }
    };
    const onUp = ()=>{
      map.off('mousemove', onMove);
      map.dragging.enable();
    };
    fullLine.on('mousedown', (e)=>{
      map.dragging.disable();
      onMove(e);
      map.on('mousemove', onMove);
      map.once('mouseup', onUp);
    });

    // --- タッチ（スマホ/タブレット） ---
    const onTouchMove = (ev)=>{
      // Leafletのlatlngが無い場合はタッチ座標から変換
      let ll = ev.latlng;
      if (!ll) {
        const t = ev.originalEvent?.touches?.[0];
        if (t) ll = map.mouseEventToLatLng(t);
      }
      if (!ll) return;
      onMove({ latlng: ll });
    };
    const onTouchEnd = ()=>{
      map.off('touchmove', onTouchMove);
      map.dragging.enable();
    };

    fullLine.on('touchstart', (e)=>{
      map.dragging.disable();
      onTouchMove(e);
      map.on('touchmove', onTouchMove, { passive: true });
      map.once('touchend', onTouchEnd);
    });
  }
  // ===== /Map seek =====



    // ---- 記録サンプル関連 ----
    let lastPushT = 0;
    let lastLatLng = null;
    function pushSample(pos){
      const t = Date.now();
      const dt = t - (lastPushT || t0);
      const lat = pos.coords.latitude, lng = pos.coords.longitude;
      const ll = L.latLng(lat, lng);

      // 1秒未満 & 5m未満の移動はスキップ（ノイズ除去）
      if (lastLatLng){
        const moved = map.distance(lastLatLng, ll);
        if (dt < 1000 && moved < 5) return;
      }

      track.push({lat, lng, t});
      lastPushT = t;
      lastLatLng = ll;

      recLenEl.textContent = fmt((t - t0)/1000);
    }

    // 静止中でも点を打つ（3秒以上更新が無ければ同座標で1点追加）
    function startKeepAlive(){
      if (keepAliveId) return;
      keepAliveId = setInterval(()=>{
        if (!t0 || !lastLatLng) return;
        const now = Date.now();
        if (now - lastPushT >= 3000) {
          track.push({ lat: lastLatLng.lat, lng: lastLatLng.lng, t: now });
          lastPushT = now;
          recLenEl.textContent = fmt((now - t0)/1000);
        }
      }, 1000);
    }
    function stopKeepAlive(){
      if (keepAliveId){ clearInterval(keepAliveId); keepAliveId = 0; }
    }

    // ---- ユーティリティ
    function fmt(sec){
      sec = Math.max(0, Math.floor(sec));
      const m = Math.floor(sec/60).toString().padStart(2,'0');
      const s = (sec%60).toString().padStart(2,'0');
      return `${m}:${s}`;
    }
    function cleanupTrackLayers(){
      if (fullLine){ map.removeLayer(fullLine); fullLine=null; }
      if (progLine){ map.removeLayer(progLine); progLine=null; }
      if (headMarker){ map.removeLayer(headMarker); headMarker=null; }
    }
    function startRecTimer(){
      if (recTimerId) return;
      recTimerId = setInterval(()=>{
        if (!t0) return;
        recLenEl.textContent = fmt((Date.now() - t0)/1000);
      }, 250);
    }
    function stopRecTimer(){
      if (recTimerId){ clearInterval(recTimerId); recTimerId = 0; }
    }

    // ---------------- 現在地表示（トグル＋精度円＋フォロー） ----------------
    const btnLocate = document.getElementById('btnLocate');
    const chkFollow = document.getElementById('chkFollow');
    let locWatchId = null;
    let meMarker = null;
    let meCircle = null;
    let didZoomToLocate = false; // 最初の測位で一度だけ最大ズーム
    let _locRetryTimer = 0;

    // 初回fixを最速で取るためのユーティリティ（成功/失敗で必ず解放）
    function getOneFix(opts = {}) {
      return new Promise((resolve, reject) => {
        const options = { enableHighAccuracy: true, timeout: 12000, maximumAge: 15000, ...opts };
        let cleared = false;
        const id = navigator.geolocation.watchPosition(
          pos => { if (!cleared){ cleared = true; navigator.geolocation.clearWatch(id); resolve(pos); } },
          err => { if (!cleared){ cleared = true; navigator.geolocation.clearWatch(id); reject(err); } },
          options
        );
      });
    }

    btnLocate.addEventListener('click', ()=>{
      if (locWatchId == null) {
        startLocate();
      } else {
        stopLocate();
      }
    });

    function startLocate(){
      if (!navigator.geolocation) { alert('このブラウザは位置情報に対応していません'); return; }
      btnLocate.classList.add('active');
      didZoomToLocate = false;

      // ① 最初の1点を素早く取得（成功すれば onLocate が走る）
      getOneFix().then(onLocate).catch(onLocateError);

      // ② 継続ウォッチ（既存があれば解除してから）
      if (locWatchId != null) navigator.geolocation.clearWatch(locWatchId);
      locWatchId = navigator.geolocation.watchPosition(onLocate, onLocateError, {
        enableHighAccuracy: true, maximumAge: 0, timeout: 15000
      });
    }

    function stopLocate(){
      if (locWatchId != null) navigator.geolocation.clearWatch(locWatchId);
      locWatchId = null;
      btnLocate.classList.remove('active');
      if (meMarker){ map.removeLayer(meMarker); meMarker = null; }
      if (meCircle){ map.removeLayer(meCircle); meCircle = null; }
    }
    function onLocate(pos){
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        const acc = Math.max(5, Math.min(200, pos.coords.accuracy || 50)); // 5–200mに制限
        const ll = L.latLng(lat, lng);

        if (!meMarker){
            meMarker = L.circleMarker(ll, {
            radius: 6, color:'#007aff', weight:3, fillColor:'#fff', fillOpacity:1
            }).addTo(map);
        } else {
            meMarker.setLatLng(ll);
        }
        if (!meCircle){
            meCircle = L.circle(ll, { radius: acc, color:'#007aff', weight:1, opacity:0.5, fillOpacity:0.1 });
            meCircle.addTo(map);
        } else {
            meCircle.setLatLng(ll); meCircle.setRadius(acc);
        }

        // ★ 最初の1回だけ「最大ズーム」で中央へ
        if (!didZoomToLocate) {
            const zs = [];
            if (typeof map.getMaxZoom === 'function') zs.push(map.getMaxZoom());
            if (osm?.options?.maxZoom != null)       zs.push(osm.options.maxZoom);
            if (gsi?.options?.maxZoom != null)       zs.push(gsi.options.maxZoom);
            const maxZ = zs.length ? Math.max(...zs) : 18; // gsi未準備でも18にフォールバック
            map.setView(ll, maxZ, { animate: true });
            didZoomToLocate = true;
        }


        // 以降はフォローON時のみパン
        if (chkFollow.checked){
            map.panTo(ll, { animate:true });
        }
    }
    function onLocateError(err){
      console.warn('locate error:', err);
      const msg = (err && (err.message || '')).toString();

      // iOSの一時的な測位不能（kCLErrorLocationUnknown / code=2）は短いバックオフで再試行
      if ((err && err.code === 2) || /kCLErrorLocationUnknown/i.test(msg)) {
        clearTimeout(_locRetryTimer);
        _locRetryTimer = setTimeout(()=>{
          getOneFix().then(onLocate).catch(e=>console.warn('retry locate failed', e));
        }, 1500);
        return;
      }

      // ユーザーが拒否
      if (err && err.code === 1) {
        alert('位置情報の許可が必要です。\nPlease allow location permission in your browser.');
        return;
      }

      // タイムアウト等その他
      alert('位置が取得できませんでした。数秒待って再度試して\nLocation unavailable. Please try again near a window.');
    }


    // ---------------- ここから：保存＆公開一覧の読み込み ----------------

    // GeoJSON 化（[lng,lat,t] の LineString）
    function buildGeoJSONFromTrack(track){
      const coordinates = track.map(p => [p.lng, p.lat, p.t]);
      return {
        type: "Feature",
        properties: {},
        geometry: { type: "LineString", coordinates }
      };
    }

    // 距離（m）
    function calcDistanceM(geom){
      try { return turf.length(geom, { units: "kilometers" }) * 1000; }
      catch { return 0; }
    }

    // 保存
    btnSave.addEventListener('click', async ()=>{
      if (!track.length) return;
      btnSave.disabled = true;

      const geom = buildGeoJSONFromTrack(track);
      const startedAt = new Date(track[0].t).toISOString();
      const endedAt   = new Date(track[track.length-1].t).toISOString();
      const distanceM = calcDistanceM(geom);

      const payload = {
        started_at: startedAt,
        ended_at: endedAt,
        duration_sec: Math.round(durationMs/1000),
        distance_m: Math.round(distanceM),
        geom
      };

      const res = await fetch("/api/private/tracks", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (res.status === 403) {
        alert("初回はログインが必要です。表示されるCloudflare Accessの画面で自分のメールで認証してください。");
      }

      if (!res.ok) {
        const err = await res.text();
        alert("保存に失敗しました: " + err);
        btnSave.disabled = false;
        return;
      }
      const json = await res.json();
      alert("保存しました！ ID: " + json.id);

      // ★ 音声が録れていれば、IDに紐づけてアップロード
      try{
        if (audioBlob){
          const fd = new FormData();
          // 任意：クライアント側で推奨ファイル名をつける
          const ext = (audioBlob.type.includes('mp4') ? 'm4a'
                    : audioBlob.type.includes('ogg') ? 'ogg'
                    : audioBlob.type.includes('wav') ? 'wav' : 'webm');
          fd.append('audio', audioBlob, `track-${json.id}.${ext}`);
          // 任意：メタデータ（録音開始時刻など）を付与
          fd.append('started_at', new Date(micT0||Date.now()).toISOString());
          fd.append('track_id', json.id);

          const ar = await fetch(`/api/private/tracks/audio`, {
            method: 'POST',
            body: fd
          });
          if (!ar.ok){
            let payload = null;
            try { payload = await ar.json(); } catch {}
            if (ar.status === 403 && payload?.error === 'quota_exceeded'){
              alert('容量上限のため、音声を保存できませんでした。Server storage quota exceeded - audio not saved.');
            } else {
              alert("音声アップロードに失敗: " + (payload?.error || await ar.text()));
            }
          }
       }
      }catch(e){
        console.warn(e);
      }

      await afterSaved(json.id); // ← 一覧＆公開レイヤをまとめて更新
    });

    async function loadAndDrawPublicTracks(){
      try{
        publicGroup.clearLayers(); // ← いったん全部消す
        const res = await fetch("/api/public/tracks?limit=50", { cache: "no-store" });
        const { tracks } = await res.json();
        for (let i = 0; i < tracks.length; i++) {
          await drawTrackLight(tracks[i].id, Math.max(0.25, 1 - i * 0.02));
        }
      }catch(e){ console.warn(e); }
    }

    async function drawTrackLight(id, alpha){
      try{
        const r = await fetch(`/api/public/tracks/${id}`);
        if (!r.ok) return;
        const { geom } = await r.json();
        const latlngs = geom.geometry.coordinates.map(c => [c[1], c[0]]);
        L.polyline(latlngs, { color: `rgba(0,122,255,${alpha})`, weight: 3, opacity: 0.9 }).addTo(publicGroup);
      }catch(e){ console.warn(e); }
    }

    // 起動時に公開トラックを描画
    loadAndDrawPublicTracks();

    // UIが地図操作を邪魔しないように
    L.DomEvent.disableClickPropagation(document.getElementById('trackCtrl'));
    L.DomEvent.disableClickPropagation(document.getElementById('locateBox'));
    L.DomEvent.disableClickPropagation(document.getElementById('loginPanel'));

    // -------- 認証状態でUIを出し分け --------
    const recPanel   = document.getElementById("recPanel");
    const loginPanel = document.getElementById("loginPanel");

    // 管理者ログインボタン：認証へ → 成功後はこのページに戻る
    document.addEventListener("click", (ev) => {
      const btn = ev.target.closest("#btnAdminLogin");
      if (!btn) return;
      const ret = location.pathname + location.search;
      location.href = "/api/private/login?return=" + encodeURIComponent(ret);
    });

    // ----- My Tracks（認証済みだけ表示） -----
    let isAuthed = false; // 認証状態を持つ
    const myPanel = document.getElementById("myTracksPanel");
    const myList  = document.getElementById("myTracksList");
    const btnRefreshTracks = document.getElementById("btnRefreshTracks");
    const myTitle = document.getElementById("myTracksTitle");

    async function refreshAuthUI() {
      try {
        const r = await fetch("/api/auth/status", { cache: "no-store" });
        const { authenticated } = await r.json();
        isAuthed = !!authenticated;

        // 記録パネル / ログインボタン（既存の挙動）
        const rec = document.getElementById("recPanel");
        const log = document.getElementById("loginPanel");
        if (rec) rec.hidden = !isAuthed;
        if (log) log.hidden =  isAuthed;

        // 右パネル：認証の有無で中身を切り替え
        if (myPanel) {
          myPanel.hidden = false; // ← どちらでも表示
          myList.textContent = "Loading...";
          if (isAuthed) {
            if (myTitle) myTitle.textContent = "My Tracks";
            await loadMyTracks();          // 管理者向け（公開/非公開/削除ボタンつき）
          } else {
            if (myTitle) myTitle.textContent = "Tracks";
            await loadPublicTracksList();  // 未認証向け（Zoomだけ）
          }
        }
      } catch (e) {
        console.warn("auth status check failed", e);
        // 安全側：記録パネル非表示、ログインボタン表示、右パネルは公開一覧に
        const rec = document.getElementById("recPanel");
        const log = document.getElementById("loginPanel");
        if (rec) rec.hidden = true;
        if (log) log.hidden = false;
        if (myPanel) {
          myPanel.hidden = false;
          if (myTitle) myTitle.textContent = "Tracks";
          await loadPublicTracksList();
        }
      }
    }
    async function loadPublicTracksList(){
      if (!myList) return;
      myList.textContent = "Loading...";
      try{
        const r = await fetch("/api/public/tracks?limit=50", { cache: "no-store" });
        if (!r.ok) { myList.textContent = "Error"; return; }
        const { tracks } = await r.json();
        if (!tracks.length) { myList.textContent = "No tracks"; return; }
        myList.textContent = "";
        tracks.forEach(t => addTrackRow(t, { viewer: true })); // ← viewerモード
      }catch(e){
        console.warn(e); myList.textContent = "Error";
      }
    }


    // 一覧取得
    async function loadMyTracks(){
      if (!myList) return;
      myList.textContent = "Loading...";
      try{
        const r = await fetch("/api/private/tracks?limit=50", { cache: "no-store" });
        if (!r.ok) { myList.textContent = "Error"; return; }
        const { tracks } = await r.json();
        if (!tracks.length) { myList.textContent = "No tracks"; return; }
        myList.textContent = "";
        tracks.forEach(addTrackRow);
      }catch(e){
        console.warn(e); myList.textContent = "Error";
      }
    }

    function addTrackRow(t, opts = {}){
      const viewer = !!opts.viewer; // true=未認証の公開一覧
      const row = document.createElement("div");
      row.className = "track-item";
      row.dataset.id = t.id;
      if (t.bbox) row.dataset.bbox = JSON.stringify(t.bbox);
      row.dataset.public = viewer ? "1" : (t.is_public ? "1" : "0");
      row.dataset.duration = String(t.duration_sec || 0);

      const started = t.started_at ? new Date(t.started_at) : null;
      const title = started
        ? started.toLocaleString('ja-JP', { year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit' })
        : t.id;

      row.innerHTML = `
        <div class="track-title">${title}</div>
        <div style="justify-self:end;">
          <span class="badge ${viewer ? 'pub' : (t.is_public ? 'pub' : 'prv')}">
            ${viewer ? 'Public' : (t.is_public ? 'Public' : 'Private')}
          </span>
        </div>
        <div class="actions" style="grid-column:1 / -1;">
          <button data-act="zoom">Zoom</button>
          ${viewer ? '' : (t.is_public
            ? '<button data-act="unpub">Unpublish</button>'
            : '<button data-act="pub">Publish</button>')}
          ${viewer ? '' : '<button data-act="del">Delete</button>'}
        </div>
        <!-- 行内プレイヤー（Zoom時に表示） -->
        <div class="player" hidden>
          <div class="controls">
            <button data-act="play">Play</button>
            <button data-act="stop">Stop</button>
            <span class="time" data-role="time">00:00 / 00:00</span>
          </div>
          <input type="range" min="0" max="1000" value="0" step="100" data-role="seek" />
        </div>
      `;
      myList.appendChild(row);
    }

    // クリック（委任）
    myList?.addEventListener("click", async (ev)=>{
      const btn = ev.target.closest("button");
      if (!btn) return;
      const row = btn.closest(".track-item");
      const id  = row?.dataset.id;
      if (!id) return;

      const act = btn.dataset.act;

      // 共通: Zoom（プレイヤーを開いてズーム＋トラック読み込み）
      if (act === "zoom") {
        // 他行のプレイヤーを畳む
        document.querySelectorAll(".track-item .player").forEach(el=>{
          if (el !== row.querySelector(".player")) el.hidden = true;
        });
        // この行のプレイヤーを開く
        const player = row.querySelector(".player");
        if (player) player.hidden = false;

        // bbox でズーム
        const bbox = row.dataset.bbox ? JSON.parse(row.dataset.bbox) : null;
        if (bbox && bbox.length === 4) {
          const b = L.latLngBounds([ [bbox[1], bbox[0]], [bbox[3], bbox[2]] ]);
          map.fitBounds(b.pad(0.25));
        }

        // トラックを読み込んで再生準備（実測スピード対応）
        await prepareViewForRow(row);
        return;
      }

      // 再生：行内プレイヤー
      if (act === "play") {
        if (row.dataset.id !== activeRowId) {
          await prepareViewForRow(row);
        }
        startViewPlayback();
        return;
      }

      // 停止：行内プレイヤー
      if (act === "stop") {
        stopViewPlayback(true); // 先頭に戻す
        return;
      }

      // ここから先は管理者専用（公開/非公開/削除）
      if (!isAuthed) return;

      if (act === "pub" || act === "unpub") {
        const is_public = act === "pub" ? 1 : 0;
        const res = await fetch(`/api/private/tracks/${id}`, {
          method: "PATCH",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ is_public })
        });
        if (!res.ok) return alert("Failed to update");
        await loadMyTracks();
        await loadAndDrawPublicTracks();
        return;
      }

      if (act === "del") {
        if (!confirm("Delete this track?")) return;
        const res = await fetch(`/api/private/tracks/${id}`, { method: "DELETE" });
        if (!res.ok) return alert("Failed to delete");
        await loadMyTracks();
        await loadAndDrawPublicTracks();
        return;
      }
    });

    // シーク（行内の range）
    myList?.addEventListener("input", (ev)=>{
      const rng = ev.target.closest('input[type="range"][data-role="seek"]');
      if (!rng) return;
      const row = rng.closest(".track-item");
      if (!row || row.dataset.id !== activeRowId) return;
      // シーク中は一旦停止して、その位置を表示
      stopViewPlayback(false);
      const ms = Number(rng.value);
      updateViewAt(ms);
    });

    // Refresh
    btnRefreshTracks?.addEventListener("click", ()=>{
      if (isAuthed) loadMyTracks(); else loadPublicTracksList();
    });

    // 保存成功後に一覧を最新化（既存の保存処理の最後に既に置いている行の直後に）
    async function afterSaved(id){
      await loadAndDrawPublicTracks();
      if (isAuthed) await loadMyTracks();
    }

    // 初期表示
    document.addEventListener("DOMContentLoaded", refreshAuthUI);
    document.addEventListener("DOMContentLoaded", () => {
      document.getElementById('btnMicStart')?.addEventListener('click', () => startMic());
      document.getElementById('btnMicStop') ?.addEventListener('click', () => stopMic());
    });
    async function prepareViewForRow(row){
      activeRowId = row.dataset.id;
      const isPub = row.dataset.public === "1";

  // 1) トラックを取得（座標＋タイムスタンプ）
  const { latlngs, timesMs, durationMs } = await fetchTrackData(activeRowId, isPub);
  if (!latlngs || latlngs.length === 0) { alert("Failed to load track."); return; }

  // 2) times の正規化（0 起点）。無い時はフォールバックを作る
  viewHasTimes = Array.isArray(timesMs) && timesMs.length === latlngs.length;
  let times = [];
  if (viewHasTimes) {
    const raw = timesMs.map(v => (typeof v === 'number' ? v : Date.parse(v)));
    const base = isFinite(raw[0]) ? raw[0] : 0;
    times = raw.map(v => isFinite(v) ? (v - base) : 0);
  } else {
    // フォールバック：距離に比例させて時間を割り当て
    const durMs = Math.max(
      1,
      (Number(row.dataset.duration || "0") * 1000) || (latlngs.length - 1) * 1000
    );
    const cum = [0];
    for (let i=1;i<latlngs.length;i++){
      const d = map.distance(latlngs[i-1], latlngs[i]);
      cum[i] = cum[i-1] + d;
    }
    const total = cum[cum.length-1] || 1;
    times = cum.map(x => Math.round(durMs * (x/total)));
  }

  // 3) 距離累積（見栄え）
  const cum = [0];
  for (let i=1;i<latlngs.length;i++){
    cum[i] = cum[i-1] + map.distance(latlngs[i-1], latlngs[i]);
  }

  // 4) 表示要素を再作成
  cleanupViewLayers();
  viewLatLngs = latlngs;
  viewTimes   = times;
  viewCum     = cum;
  viewTotal   = cum[cum.length-1];
  viewDurMs   = Math.max(1, times[times.length-1] ?? durationMs ?? 1);

  viewFull = L.polyline(viewLatLngs, { color:'#666', weight:4, opacity:0.5 }).addTo(viewGroup);
  viewProg = L.polyline([], { color:'#007aff', weight:5, opacity:1 }).addTo(viewGroup);
  viewHead = L.circleMarker(viewLatLngs[0], {radius:6, color:'#007aff', fillColor:'#fff', fillOpacity:1, weight:3}).addTo(viewGroup);

  // 5) 行内プレイヤーの初期化
  const timeEl = row.querySelector('.time[data-role="time"]');
  const seekEl = row.querySelector('input[type="range"][data-role="seek"]');
  if (seekEl){ seekEl.max = String(Math.max(1, viewDurMs)); seekEl.value = "0"; }
  if (timeEl){ timeEl.textContent = `00:00 / ${fmt(viewDurMs/1000)}`; }

  // 0ms に反映
  updateViewAt(0);

  // ★ 音声の読み込み（ログイン時のみ private API を使用）
  const a = document.getElementById('recAudio');
  if (a) {
    try { a.pause?.(); } catch {}
    if (isAuthed) {
      a.src = `${location.origin}/api/private/tracks/audio?id=${encodeURIComponent(activeRowId)}`;
      a.load(); // メタデータを読み込む
      } else {
        a.removeAttribute('src');
        a.load();
      }
    }
}

async function fetchTrackData(id, isPublic){
  const url = isPublic ? `/api/public/tracks/${id}` : `/api/private/tracks/${id}`;
  const r = await fetch(url, { cache: 'no-store' });
  if (!r.ok) return { latlngs:null, timesMs:null, durationMs:0 };
  const { geom } = await r.json();

  // GeoJSON LineString
  const coords = geom?.geometry?.coordinates || [];
  // [lng,lat,(time?)] → [lat,lng] と time(ms) へ
  const latlngs = [];
  const timesMs = [];
  for (const c of coords) {
    latlngs.push([c[1], c[0]]);
    if (c.length >= 3) timesMs.push(c[2]); // ← 保存時に入れている「絶対ms」を使用
  }

  // 予備：properties.times / timestamps / duration_ms（あれば使えるように）
  const props = geom?.properties || {};
  if (!timesMs.length && Array.isArray(props.times)) {
    timesMs.push(...props.times);
  } else if (!timesMs.length && Array.isArray(props.timestamps)) {
    timesMs.push(...props.timestamps);
  }
  const durationMs = Number.isFinite(props.duration_ms) ? props.duration_ms : 0;

  return { latlngs, timesMs, durationMs };
}

function startViewPlayback(){
  if (!viewLatLngs || viewLatLngs.length < 2) return;
  if (viewPlaying) return;
  viewPlaying = true;
  viewStartWall = performance.now();

  // 現在のシーク位置から再開
  const row = document.querySelector(`.track-item[data-id="${activeRowId}"]`);
  const seekEl = row?.querySelector('input[type="range"][data-role="seek"]');
  viewStartT = seekEl ? Number(seekEl.value) : 0;

  // ★ 音声も同じ位置から再生
  const a = document.getElementById('recAudio');
  if (a && a.src){
    const startSec = (viewStartT || 0) / 1000;
    if (a.readyState >= 1) a.currentTime = startSec;
    else a.addEventListener('loadedmetadata', ()=>{ a.currentTime = startSec; a.play().catch(()=>{}); }, { once:true });
    a.play().catch(()=>{});
  }
  tickView();
}

function stopViewPlayback(resetToZero){
  if (viewRAF) cancelAnimationFrame(viewRAF);
  viewRAF = 0; viewPlaying = false;
  const a = document.getElementById('recAudio');
  try { a?.pause(); } catch {}
  if (resetToZero) updateViewAt(0);
}

function tickView(){
  if (!viewPlaying) return;
  const now = performance.now();
  const elapsed = now - viewStartWall;
  const t = viewStartT + elapsed;
  updateViewAt(t);
  if (t >= viewDurMs) { stopViewPlayback(true); return; }
  viewRAF = requestAnimationFrame(tickView);
}

function updateViewAt(ms){
  // 0..viewDurMs の範囲に収める
  const t = Math.max(0, Math.min(viewDurMs, ms));

  // 時間列に基づく補間（実測スピード）
  let idx = 0;
  while (idx < viewTimes.length - 1 && viewTimes[idx+1] < t) idx++;

  const tA = viewTimes[idx];
  const tB = viewTimes[Math.min(idx+1, viewTimes.length-1)];

  const a = viewLatLngs[idx];
  const b = viewLatLngs[Math.min(idx+1, viewLatLngs.length-1)];

  // a,b が [lat,lng] 配列か、LatLngオブジェクトかに対応
  const aLat = Array.isArray(a) ? Number(a[0]) : Number(a?.lat);
  const aLng = Array.isArray(a) ? Number(a[1]) : Number(a?.lng);
  const bLat = Array.isArray(b) ? Number(b[0]) : Number(b?.lat);
  const bLng = Array.isArray(b) ? Number(b[1]) : Number(b?.lng);

  if (!isFinite(aLat) || !isFinite(aLng) || !isFinite(bLat) || !isFinite(bLng)) {
    // 座標不正なら描画をスキップ
    return;
  }

  const span = Math.max(1, tB - tA); // 0割防止
  const segF = Math.max(0, Math.min(1, (t - tA) / span));
  const pLat = aLat + (bLat - aLat) * segF;
  const pLng = aLng + (bLng - aLng) * segF;
  const p = L.latLng(pLat, pLng);

  // ライン更新（見栄え：進捗は距離ベースでスムーズに伸ばす）
  const upto = viewLatLngs.slice(0, idx+1).map(pt =>
    Array.isArray(pt) ? [pt[0], pt[1]] : [pt.lat, pt.lng]
  );
  upto.push([p.lat, p.lng]);
  viewProg.setLatLngs(upto);
  viewHead.setLatLng(p);

  // 行内 UI
  const row = document.querySelector(`.track-item[data-id="${activeRowId}"]`);
  const timeEl = row?.querySelector('.time[data-role="time"]');
  const seekEl = row?.querySelector('input[type="range"][data-role="seek"]');
  if (seekEl) seekEl.value = String(Math.round(t));
  if (timeEl) timeEl.textContent = `${fmt((t/1000)||0)} / ${fmt((viewDurMs/1000)||0)}`;
  
  // ★ 音声は「停止中/シーク中のみ」時間を合わせる（再生中は触らない）
  const audioEl = document.getElementById('recAudio');
  if (audioEl instanceof HTMLAudioElement && audioEl.src && !viewPlaying) {
    const sec = t / 1000;
    if (audioEl.readyState >= 1) {
      audioEl.currentTime = sec;
    } else {
      audioEl.addEventListener('loadedmetadata', () => {
        audioEl.currentTime = sec;
      }, { once: true });
    }
    // 停止中は位置だけ合わせる（pauseは今のままでOK）
    try { audioEl.pause(); } catch {}
  }
}
  </script>
</body>
</html>
